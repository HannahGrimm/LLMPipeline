(set-logic ALL)
(declare-datatype Tuple ((empty) (mkTuple (getField0 Int))))

(declare-var tmp_preCon Int)
(declare-var tmp_postCon Int)
(declare-var j_preCon Int)
(declare-var j_postCon Int)
(declare-var i_preCon Int)
(declare-var i_postCon Int)

(define-fun preCondition ((tmp_preCon Int) (j_preCon Int) (i_preCon Int)) Bool (and (and (exists ( (var_q Int)) (and (>= var_q 0) (< var_q (seq.len A)) (= (seq.nth A var_q) x))) (not false) (> (seq.len A) 0) (< (seq.len A) 10) (>= i_preCon 0) (< i_preCon (seq.len A)) (exists ( (var_q Int)) (and (>= var_q 0) (< var_q (seq.len A)) (= (seq.nth A var_q) x))) (= true true) (= true true) true)))

(define-fun postCondition ((tmp_postCon Int) (j_postCon Int) (i_postCon Int)) Bool (and (and (exists ( (var_q Int)) (and (>= var_q 0) (< var_q (seq.len A)) (= (seq.nth A var_q) x))) (= i_postCon (- (seq.len A) 1)))))

(synth-fun targetFunction ((tmp Int) (j Int) (i Int)) Tuple)

(declare-var tmp_in Int)
(declare-var j_in Int)
(declare-var i_in Int)
(declare-var i_out Int)

(constraint (forall ((tmp_in Int) (j_in Int) (i_in Int) (i_out Int)) (=>
	(and
		(preCondition tmp_in j_in i_in)
		(= i_out (getField0 (targetFunction tmp_in j_in i_in)))
	)
	(and
		(postCondition tmp_in j_in i_out)
	)
)))
(check-synth)